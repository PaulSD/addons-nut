#!/bin/bash

Usage()
{
  [ -n "$1" ] && { echo "ERROR: $1" >&2 ; echo >&2 ; }
  cat <<END >&2
Usage: $ScriptName [options]

This script is intended to support:
* Checking for upstream updates (for all Add-ons in this repository),
  incorporating any upstream updates into the Add-ons, and automatically
  releasing new Add-on versions when appropriate.
* Changing URLs and maintainer references (including in all Add-ons in this
  repository), for use after forking this Git repository.

Be aware that automation for additional use cases is available via the \`update\`
script in each Add-on directory.  (Most of the functionality here is implemented
by calling those scripts.)

This script is primarily intended to be run by a GitHub workflow, but may be run
manually.

By default, all changes will be committed to Git and pushed.

Options:

  --git-repo <url>       Specify this Git repository's URL.
    If run by a GitHub workflow and this is not specified, the Git repository
    URL will be automatically detected, and configs will only be changed if the
    URL changes.
    If run manually and this is not specified, URLs based on the Git repository
    URL will not be changed.
  --ha-repo <url>        Specify the URL where this HA Add-on Repo is published.
    In most cases this should be the Git repository's URL, but it may be
    different if the HA Add-on Repository is separate from the source Git repo.
    If --git-repo is specified and this is not specified, the --git-repo URL
    will be used.
    If run by a GitHub workflow and the Git repository URL changes and this and
    --git-repo are not specified, the Git repository URL will be used.
  --maintainer <value>   Specify maintainer.
    HA recommends setting this to 'Full Name <email@example.com>'.
    If run by a GitHub workflow and the Git repository URL changes and this is
    not specified, the Git repository owner username or owner URL (depending on
    where it is used) will be used.
    If run manually and this is not specified, maintainer references will not be
    changed.

  --no-addon-update      Do not run the \`update\` script for each Add-on.
    (Only perform functionality that does not depend on those scripts.)
  -U, --no-upstream-update
    Do not check for upstream updates for each Add-on.

  -C, --no-commit        Do not commit changes to Git.  Implies --no-push.
  --no-push              Do not push Git commits.

END
  exit 1
}

ScriptName="$(basename "$0")"
NewGitRepo=
NewHARepo=
NewMaintainer=
AddonUpdate='y'
GitCommit='y'
GitPush='y'
AddonUpdateArgs=()

# Parse command-line arguments.
while [ $# -gt 0 ] ; do
  case "$1" in
    --git-repo)
      [ $# -eq 1 ] && Usage "URL required after '$1'"
      shift
      NewGitRepo="$1"
      AddonUpdateArgs+=(--git-repo "$NewGitRepo")
    ;;
    --ha-repo)
      [ $# -eq 1 ] && Usage "URL required after '$1'"
      shift
      NewHARepo="$1"
      AddonUpdateArgs+=(--ha-repo "$NewHARepo")
    ;;
    --maintainer)
      [ $# -eq 1 ] && Usage "Maintainer value required after '$1'"
      shift
      NewMaintainer="$1"
      AddonUpdateArgs+=(--maintainer "$NewMaintainer")
    ;;
    --no-addon-update)
      AddonUpdate='n'
    ;;
    -U|--no-upstream-update)
      AddonUpdateArgs+=(--no-upstream-update)
    ;;
    -C|--no-commit)
      GitCommit='n'
      GitPush='n'
      AddonUpdateArgs+=(--no-commit)
    ;;
    --no-push)
      GitPush='n'
      # --no-push is added to $AddonUpdateArgs below.
    ;;
    -h|--help)
      Usage
    ;;
    *)
      Usage "Invalid option '$1'"
    ;;
  esac
  shift
done

set -e
Script="$(which "$0")"
cd "$(dirname "$Script")"  # This script's path

# Check for changes that haven't been committed in Git.
if [ -n "$(git status -s)" ] ; then
  echo 'ERROR: Detected changes that have not been committed in Git.' >&2
  echo 'Please commit or stash your changes in Git before running this script.' >&2
  exit 10
# Check for Git commits that haven't been pushed.
elif [ "$GitPush" = 'y' ] && ! git diff --quiet @{push}..HEAD ; then
  echo 'ERROR: Detected Git commits that have not been pushed.' >&2
  echo 'Please push your Git commits before running this script.' >&2
  exit 11
fi

# Load saved parameters:
# * $GitRepo is used to detect Git repository URL changes.
source .update.conf

# If --git-repo is specified and --ha-repo is not specified, use the new Git repository URL as the
# HA Add-on Repo URL.
if [ -n "$NewGitRepo" ] && [ -z "$NewHARepo" ] ; then
  NewHARepo="$NewGitRepo"
fi

# If --git-repo is not specified and script was run by a GitHub workflow, detect the Git repository
# URL, and determine whether it changed.
if [ -z "$NewGitRepo" ] && [ -n "$GITHUB_SERVER_URL" ] && [ -n "$GITHUB_REPOSITORY" ] ; then
  NewGitRepo="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY"
  if [ "$NewGitRepo" = "$GitRepo" ] ; then
    #echo "No change to Git repository URL."
    NewGitRepo=
  else
    echo -e "Git repository URL changed from '$GitRepo'\nto '$NewGitRepo'."
    # If --ha-repo was not specified, use the new Git repository URL as the HA Add-on Repo URL.
    [ -z "$NewHARepo" ] && NewHARepo="$NewGitRepo"
    # If --maintainer was not specified, use the Git repository owner username as the Maintainer.
    # We only use the owner username in this script.  If the owner URL is needed, use:
    # "$GITHUB_SERVER_URL/$GITHUB_REPOSITORY_OWNER"
    [ -z "$NewMaintainer" ] && NewMaintainer="$GITHUB_REPOSITORY_OWNER"
  fi
fi

# Update saved parameters.
File='.update.conf'
rm -f "$File.new"
for VarName in GitRepo ; do
  NewVarName="New$VarName"
  if [ -n "${!NewVarName}" ] ; then  # if [ -n "$NewVar" ] ; then
    declare "Old$VarName=${!VarName}" # OldVar="$Var"
    declare "$VarName=${!NewVarName}"  # Var="$NewVar"
  fi
  # Write variable definition to file.
  printf '%s\n' "$VarName='${!VarName}'" >> "$File.new"
done
mv "$File.new" "$File"
if ! git diff --quiet "$File" ; then
  echo "Changed '$File'."
  git add -- "$File"
fi

# After this point:
# For parameters that are not being updated, only $Var will be set.
# For parameters that are being updated, $Var will be set to the new value, and $NewVar/$OldVar will
# be set to the new/old values.  If the new parameters were specified using command line arguments,
# it is possible that the old and new values will be the same, in which case configs should still be
# validated/updated (to make it easy to re-apply changes or apply new changes after script updates).

#
# Handle config changes.
#

# Since the config changes applied by this script may not work in all cases (and may need to be
# manually overridden in some cases), we only apply config changes when requested by command line
# arguments or when run by a GitHub workflow and the Git repository URL changes (as opposed to
# verifying/changing the configs on every run even if the inputs have not changed, which would
# ensure consistency and make it easier to apply new changes after script updates but would
# interfere with manual overrides).

# Convenience function.
Changed() {
  local File="$1" Field="$2"
  if ! git diff --quiet "$File" ; then
    echo "Changed $Field in '$File'."
    git add -- "$File"
  else
    echo "No change to $Field in '$File'."
  fi
}

if [ -n "$NewHARepo" ] ; then
  File='repository.yaml' Field="'url' (HA Add-on Repo URL)"
  perl -i -p -e "BEGIN { \$n = '$NewHARepo'; }"' s/^(url:[ \t]*).*$/$1"$n"/;' "$File"
  Changed "$File" "$Field"
fi

if [ -n "$NewMaintainer" ] ; then
  File='repository.yaml' Field="'maintainer'"
  perl -i -p -e "BEGIN { \$n= '$NewMaintainer'; }"' s/^(maintainer:[ \t]*).*$/$1"$n"/;' "$File"
  Changed "$File" "$Field"
fi

# If the above resulted in any changes then commit the changes to Git.
if [ "$GitCommit" = 'y' ] && [ -n "$(git status -s)" ] ; then
  # For this use case, `git commit ...` is sufficient.
  # For other use cases, `git add --all -- . ; git commit --all ...` may be needed.
  git commit --message "(./$ScriptName) Update repository config"
fi

#
# End of config changes.
#

# Run the `update` script for each Add-on.
if [ "$AddonUpdate" = 'y' ] ; then
  # Each script will commit its own changes, but to avoid triggering redundant GitHub workflow runs,
  # $AddonUpdateArgs always includes --no-push, and this script pushes after all scripts have been
  # run.
  AddonUpdateArgs+=(--no-push)
  while read -u3 -r -d $'\0' Script ; do
    "$Script" "${AddonUpdateArgs[@]}"
  done 3< <(find -L . -mindepth 2 -maxdepth 2 -name update -type f -executable -print0)
fi

# If the above resulted in any commits then push Git.
if [ "$GitPush" = 'y' ] && ! git diff --quiet @{push}..HEAD ; then
  git push
fi

echo "'./$ScriptName' completed successfully."
